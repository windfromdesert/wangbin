# Python学习手册之学习笔记

## 第一部分：使用入门

## 第1章：问答环节

在Python的思维方式中，明了胜于晦涩，简洁胜于复杂

实际上，作为一种通用语言，Python的应用角色几乎是无限的：你可以在任何场合应用Python。

最常见的应用领域：

1. 系统编程
2. 用户图形接口
3. Internet脚本
4. 组件集成
5. 数据库编程
6. 快速原型
7. 游戏、图像、人工智能、XML、机器人等

你可以用Python做到一切用Perl能做到的事。Python更强化了可读性。

+ 比TCL强大
+ 比Perl更简洁，更具可读性，更易维护，有助于减少程序bug
+ 比Java更简单、更易于使用
+ 比C++更简单、更易于使用，但通常也不与C++竞争
+ 比VB更强大也更具备跨平台特性
+ 比Ruby更成熟、语法更具可读性
+ 具备SmallTalk和Lisp等动态类型的特性

## 第2章：Python如何运行程序

当程序执行时，Python会先将源代码编译成所谓的字节码的形式。你会注意到，前面所提到的这个过程对于你来说完全是隐藏起来的，如果Python进程在机器上拥有写入权限，那么它将把程序的字节码保存为一个以.pyc为扩展名的文件（".pyc"就是编译过的".py"源代码）。当程序运行之后，你会在源代码附近（也就是说同一个目录下）看到这些文件。

Python这样保存字节码是作为一种启动速度的优化。下一次运行程序时，如果你在上次保存字节码之后没有修改过源代码的话，Python将会加载.pyc文件并跳过编译这个步骤。当Python必须重编译时，它会自动检查源文件和字节码文件的时间戳：如果你又保存了源代码，下次程序运行时，字节码将自动重新创建。如果Python无法在机器上写入字节码，程序仍然可以工作：字节码将会在内存中生成，并在程序结束时简单地丢弃。

字节码文件同样是分发Python程序的方法之一。如果Python找到的都是.pyc文件，它也很乐意于运行这个程序，尽管这里没有原始的.py源代码文件。

源代码（m.py）-->字节码（m.pyc）-->运行时（PVM）

性能：Python字节码不是机器的二进制代码。字节码是Python定义的一种表现形式。这就是Python无法运行得像C或C++代码一样快的原因。实际的效果就是纯Python代码的运行速度介于传统的编译语言和传统的解释语言之间。

**执行优化工具**

1.  Psyco实时编译器

    Psyco是一个PVM的增强工具。这个工具可以将部分程序的字节码转换成底层的真正的二进制机器代码，从而实现更快的执行速度。在开发的过程中，Psyco无需代码的修改或独立的编译步骤即可完成这一转换。因为字节码的转换与程序运行同时发生，所以Psyco往往被看作是一个即时编译器。

2.  Shedskin C++转换器

**冻结二进制文件**

真正的Python编译器。让Python程序生成独立的可执行二进制代码的简单方法。如今，主要有三种系统能够生成冻结二进制文件：

1. py2exe--windows下使用
2. Pyinstaller--Linux和UNIX上使用
3. freezo

冻结二进制文件与真实的编译输出结果有所不同：它们通过虚拟机运行字节码。所以如果离开了必要的初始改进，冻结二进制文件和最初的源代码程序运行速度完全相同。因为在冻结二进制文件中嵌入了Python，接收端并不需要安装Python来运行这些冻结二进制文件。此外，由于代码嵌入在冻结二进制代码之中，对于接收者来说，代码都是隐藏起来的。

## 第三章：如何运行程序

### 交互模式下编写代码

+ 在unix机器上输入Ctrl-D退出，在MS-DOS和Windows系统中输入Ctrl-Z退出。
+ Python解释器会在每行代码输入完成后，也就是按下回车后立即执行。
+ 除了在Shell窗口中输入Python，也可以通过使用IDLE主窗口，或者在Windows开始按钮上的Python腰间中通过选择“Python(command-line)”这个选项开始简单的交互会话。

> 需要牢记的第一条原则：当你对一段Python代码的运行有任何疑问的时候，马上打开交互命令行并实验代码，看看会发生什么。

+ 使用交互提示模式需要牢记的一些技巧：
    1. 只能够输入Python命令。首先，记住只能在Python交互模式下输入Python代码，而不要输入系统的命令。
    2. 在文件中打印语句是必须的。在交互解释器中自动打印表达式的结果，不需要输入完整的打印语句，但是换成在文件中编写代码时，就必须使用print语句来进行输出。
    3. 在交互模式下不需要缩进（目前还不需要）。当输入Python程序时，无论是在交互模式下还是在一个文本文件中，请确定所有没有嵌套的语句都在第一列（也就是说要在最左边）。否则Python也许会产生错误信息。
    4. 留意提示符的变换和复合语句。当在交互模式下输入二行或多行的复合语句时，提示符会发生变化。在简单的shell窗口界面中，交互提示符会在第二行及后边的行由>>>变成...；在IDLE界面中，第一行之后的行会被自动缩进。无论哪种情况，都需要插入一个空行（在这行的起始位置点击回车键），告诉交互模式的Python，已经完成了多行语句的输入；与之相比，文件中的空行将会被省略。

### 系统命令行和文件

交互命令行的缺点：不能保存命令，为了重新运行，不得不从头开始输入。

为了能够永久的保存程序，需要在文件中写入代码，这样的文件往往被看作模块，模块是一个包含了Python语句的简单文本文件。可以用多种方式去运行：通过系统命令行、通过点击图标、通过在IDLE用户界面中选择等。

模块文件常常作为Python写成的程序。也就是说，一个程序是由一系列预编写好的语句构成，保存在文件中，从而可以反复执行。可以直接运行的模块文件往往也称作脚本（一个顶层程序文件的非正式说法）。有些人将“模块”这个说法应用在被另一个文件所导入的文件。

系统Shell提示模式下输入：（PS:在新版windows中可以省略程序名称'python'）

    % python spam.py  
    256  
    the bright side of life
    
输入这样的系统shell命令，记住如果没有配置PATH这个参数的话，需要将“python”替换成完整的路径。 

可以用如下语句重定向python的输出到一个文件，以便以后使用。

    % python spam.py > saveit.txt

这样，之前运行输出的那两行就保存在了saveit.txt文件中了。

使用命令行和文件时要注意的陷阱：

+ 注意windows上的默认扩展名。
+ 在系统提示模式下使用文件扩展名，但是在导入时别使用文件扩展名。
+ 在文件中使用打印语句。

### UNIX可执行脚本(#!)

UNIX风格的可执行脚本包含了python语句的一般文本文件，但有两个特殊的属性：

1. 它们的第一行是特定的。脚本的第一行往往以字符#!开始（常常称作"hash bang"），其后紧跟着机器Python解释器的路径。
2. 它们往往都拥有可执行的权限。

UNIX类系统的例子。使用文本编辑器创建一个名为brian的文件：

    #!/usr/local/bin/python  
    print 'The Bright Side of Life...'

文件顶端的特定一行告诉系统Python解释器保存在哪里；并且注意这个文件命名为brian，没有象之前模块文件一样使用.py后缀；当然给文件增加.py后缀也没有关系。如果通过使用chmod +x brian这条shell命令赋予了这个文件可执行的权限，那么就可以在系统shell中运行它，就好象是一个二进制文件一样。（在较新版的Windows中，只需在系统shell中输入.py文件名称即可运行Python程序，这类似于UNIX的#!）

UNIX env查找技巧。在文件特定的第一行注释中象这样写：

    #!/usr/bin/env python
    ...script goes here...

当这样编写代码的时候，env程序可以通过系统的搜索路径的设置（例如，在绝大多数的UNIX shell中，通过搜索PATH环境变量中罗列出的所有目录）定位Python解释器。这种方法可以使代码更具可移植性，但是在“env在任何系统中都是相同路径”的前提下。

该脚本方法是UNIX的一个技巧，对Windows用户可能并不可行。

### 在Windows中点击文件图标

raw_input的技巧

在默认情况下，Python会生成弹出一个黑色DOS终端窗口作为文件的输入或输出。但是在程序退出时，终端窗口关闭并消失。也就是我们看到的一闪而过。

解决办法。如果需要通过图标点击运行脚本时，脚本输出后暂停，可以简单地在脚本的最后添加内置raw_input函数的调用语句。

    # 注释
    import sys
    print sys.platform
    primt 2 ** 100
    raw_input()                 # ADDED

这样，raw_input读取标准输入的下一行，如果没有得到的话就一直等待输入。执行的效果就是让脚本暂停，因此能够显示输出窗口，直到按下回车键为止。

这个技巧，只针对Windows中才是必要的。没有理由在任何其他的情况下在文件中增加这个调用。

+ 可选的接受字符串，这些字符串将作为提示打印出来[例如，raw_input('Press Enter to exit')]。
+ 以字符串的形式为脚本返回读入的文本[例如，nextinput = raw_input()]。
+ 在系统shell的层面上支持输入流的重定向(例如，python spam.py < input.txt)，就象输出时的打印语句一样。

即使使用了raw_input的技巧，点击文件图标仍有一定的风险，你可能看不到Python的错误信息。所以，最好将点击图标看作程序调试之后运行的一种方法。通过系统命令行或IDLE，以便能够看到生成的错误信息，并在不使用编码技巧的情况下，观察正常的输出结果。

### 模块导入和重载

简单来讲，每一个以扩展名.py结尾的Python源代码文件都是一个模块。

模块导入可用通过简单的import来实现

    >>> import script4
    win32
    1267650600228229401496703205376

这可以运行，但默认每次会话只能运行一次。导入必须找到文件，将其编译成字节码，并且运行代码。如果想要Python在同一次会话中再次运行文件（不停止和重新启动会话），需要调用内置的reload（重载）函数。

    >>>reload(script4)
    win32
    ......
    <module 'script4' from 'script4.py'>
    >>>

reload是一个被调用的函数，而import是一个语句，这也就是为什么你必须传递模块名称给reload函数作为括号中的参数，并且这也是为何在重载时得到了额外的一行输出的原因。reload函数的返回值是一个Python模块对象。

**模块的显要特性：属性**

一个模块文件的变量名可以通过两个Python语句读取--import和from，以及reload调用。

    % python
    >>> import myfile
    >>> print myfile.title

或者

    % python
    >>> from myfile import title
    >>> print title
    
from和import很相似，只不过增加了对载入组件的变量名的额外赋值。能够简单的以title(一个变量)导入字符串而不是myfile.title(一个属性引用)。通过import得到了具有属性的模块，而使用from时，则会获得文件变量名的拷贝。

在模块文件中编写多个变量名，内置的dir函数开始发挥作用。可以用它来获得模块内部的可用的变量名的列表。

    >>> dir(threenames)
    ['__builtins__','__doc__','__file__','__name__','a','b','c']
    
dir函数将返回这个模块内部的所有属性。一些双下划线开头并结尾的变量名，这些通常都是由Python预定义的内置变量名，对于解释器来说有特定的意义。那些通过代码而定义的变量(a,b和c)在dir结果的最后显示。    

**模块和命名空间**

一般来说，Python程序往往由多个模块文件构成，通过import语句连接在一起。每个模块文件是一个独立完备的变量包装，即一个命名空间。实际上，就象你将看到的那样，正是由于模块将变量封装成不同部分，Python具有了能够避免命名冲突的优点。模块是一个不需要重复输入而可以反复运行代码的方法。

**import和reload的使用注意事项**

import与reload会让人变得困惑：需要记住是何时导入的，才能知道能否reload，需要记住当调用reload时需要使用括号，并且要记住让代码的最新版本运行时首先要使用reload。由于这些复杂的地方，我们要避免使用import和reload启动程序的冲动。

execfile('module.py')内置函数是另一个通过交互提示而不需要import或之后reload运行文件的方法。它有类似的效果，但从技术上讲并没有导入模块。

### IDLE用户界面

**IDLE基础**

**使用IDLE要点**

+ 当保存文件时，必须明确地添加“.py”。
+ 通过选择在文本编辑窗口Run-Run Module运行脚本，而不是通过交互模式的导入和重载。
+ 你也许仍然需要重载嵌套的模块。
+ 可以对IDLE进行定制。
+ 在IDLE中没有清屏选项。
+ Tkinter GUI和线程程序有可能不适用于IDLE。
+ 如果发生了连接错误，试一下通过单个进程的模式启动IDLE。尤其在Windows系统中，如果碰到这样的错误，常常可以通过系统命令行使IDLE运行在单一进程的模式下进行启动，-n标志位可以强制进入这种模式。例如，可以开启一个命令行窗口，并从C:\Python27\lib\idlelib(如果必要的话，使用cd切换到这个目录下)，运行系统命令行idle.py -n
+ 谨慎使用IDLE的一些可用的特性。例如，IDLE可以在运行脚本时，代码中的变量自动在IDLE对话中显示，不需要总是运行import命令去获取已运行的顶层文件的变量名，这很方便，但是在IDLE之外的环境会让人很困惑，变量名只有在从文件中导入才能使用。

**高级IDLE工具**

+ 指向点击程序调试和对象浏览器
+ 可以在文本编辑器中的某一行点击右键，从而在代码中设置断点停止它的运行、显示变量值等。也可以在调试时查看程序的执行效果，在代码中执行该步时，当前运行的代码就会被标注出来。
+ 一个小技巧：使用鼠标，通过在错误信息的文字上进行右键点击来快速地跳到发生错误的那一行代码。使得修改并重新运行代码变得简单快捷。
+ IDLE提供了丰富的、友好的工具集合。

**其他的IDE**

+ Eclipse和PyDev
+ Komodo
+ PythonWin

### 嵌入式调用

在一些特定的领域，Python代码也许会在一个封闭的系统中运行。在这样的情况下，我们说Python程序被嵌入在其它程序中运行。例如，从C程序中通过调用Python运行API的函数创建并运行Python代码是可行的。

### 冻结二进制的可执行性

冻结二进制的可执行性是集成了程序的字节码以及Python解释器为一个单个的可执行程序的包。通过这种方式，Python程序可以象其他可执行程序一样被启动。一般是在产品发售前进行封装。

### 文本编辑器启动的选择

一般来说，如果是刚刚开始学习Python，应该使用IDLE界面做开发。

如果你是一个有经验的程序员，你也许觉得这样的方式更惬意一些：简化成在一个窗口使用你选择的文本编辑器，在另一个窗口通过命令行或点击图标启动编写程序。

你最喜欢使用的环境，往往就是最适合你用的环境。

## 第二部分：类型和运算

## 第四章：介绍Python对象类型

Python程序可以分解成模块、语句、表达式以及对象。

1. 程序由模块构成。
2. 模块包含语句。
3. 语句包含表达式。
4. 表达式建立并处理对象。

### Python的核心数据类型

数字，字符串，列表，字典，元组，文件，其他类型（集合、类型、None、布尔型）

Python中没有类型声明，运行的表达式，决定了建立和使用的对象的类型。

Python是动态类型的（它自动地跟踪你的类型而不是要求声明代码），但是它也是强类型语言（你只能对一个对象进行有效的操作）。

### 数字

整数、浮点数、少见的类型（无限精度“长”整型、有虚部的复数、固定精度的十进制数以及集合等）

加号(+)代表加法，星号(*)在乘法中使用，双星号(**)在乘方运算中使用。

运算结果末尾的“L”，当需要有额外的精度时，Python自动将整型变换升级成为长整型。

对象的显示：全精度以及用户友好的形式

math模块：包括了作为函数的更高级的数学工具。

random模块：可以作为随机数字的生成器和随机选择。

### 字符串

**序列的操作**

字符串序列：从左到右的顺序，序列中的元素根据它们的相对位置进行存储和读取。从严格意义上来说，字符串是一个单个字符的字符串的序列。

作为序列，字符串支持假设其中各元素包含位置顺序的操作。例如：

    >>> S = 'Spam'
    >>> len(S)
    4
    >>> S[0]
    'S'
    >>> S[1]
    'p'

在Python中，索引是按照从最前面的偏移量进行编码的，也就是从0开始，第一项为0，第二项为1，依此类推。

也可以反向索引：S[-1] S[-2] ...。从-1开始。一般来说，一个负的索引号简单地与字符串的长度相加，得到两个操作是等效的。

我们也可以在方括号里使用任意表达式，不仅仅使用数字常量。

序列也支持一种所谓分片的操作，这是一种一步就能够提取整个分片(slice)的方法。例如：

    >>> S
    'Spam'
    >>> S[1:3]
    'pa'

分片操作的一般形式为X[I:J]，表示取出在X中从偏移为I，直到但不包括J的内容。

在一个分片中，左边界默认为0，并且右边界默认为分片序列的长度。

字符串也支持使用加号进行合并，将各个字符串合成为一个新的字符串，或者重复。

    >>> S + 'xyz'
    'Spamxyz'
    >>> S * 3
    SpamSpamSpam

**不可变性**

字符串在Python中具有不可变性，在其创建后值不能改变。例如，你不能通过对其某一位置进行赋值而改变字符串，但你总是可以通过建立一个新的字符串并以同一个变量名对其进行赋值。因为Python在运行过程中会清理旧的对象。

在Python中的每一个对象都可以分为不可变性或者可变性。在核心类型中，数字、字符串和元组是不可变的；列表和字典不是这样（它们可以完全自由的改变）。

**类型特定的方法**

字符串的find方法是一个基本的子字符串查找的操作，它将返回一个传入子字符串的偏移量，或者没有找到的情况下返回-1；而字符串的replace方法将会对全局进行搜索和替换。

    >>> S.find('pa')
    1
    >>> S
    'spam'
    >>> S.replace('pa','XYZ')
    'SXYZm'
    >>> S
    'Spam'

    >>> line = 'aaa,bbb,ccccc,dd'
    >>> line.split(',')
    ['aaa','bbb','ccccc','dd']

    >>> S = 'spam'
    >>> S.upper()
    'SPAM'

    >>> S.isalpha()                     # content tests:isalpha,isdigit,etc
    True

    >>> line = 'aaa,bbb,ccccc,dd\n'
    >>> line = line.rstrip()
    >>> line
    'aaa,bbb,ccccc,dd'

**录求帮助**

可以参考Python的标准库参考手册，或者相关参考书，但是dir和help是Python文档的首要选择。

    >>> dir(S)

    >>> help(S.index)

**编写字符串的其他方法**

    >>> S = 'A\nB\tC'                   # \n is end-of-line, \t is tab
    >>> len(S)                          # each stands for just one character
    5

    >>> ord('\n')                       # \n is a byte with the binary value 10 in ASCII

    >>> S = 'A\0B\0C'                   # \0,the binary zero byte,does not terminate the string
    >>> len(S)
    5

Python还允许字符串在三个引号（单引号或双引号）中表示多行字符串的形式。这时，会在每一行的末尾增加一个换行符'\n'。这使得在Python脚本中嵌入像HTML或XML内容时很方便。

**模式匹配**

    >>> import re
    >>> match = re.match('/(.*)/(.*)/(.*)','/usr/home/lumberjack')
    >>> match.groups()
    ('usr','home','lumberjack')

模式中括号包含的部分与子字符串中匹配对应的部分保存为组。从而进行特定的操作。

### 列表

列表是一个任意类型的对象的位置相关的有序集合。它没有固定的大小。通过对偏移量进行赋值以及其他各种列表的方法进行调用，列表确实能够修改其大小。

**序列操作**

列表支持所有的我们对字符串所讨论过的序列操作。唯一的区别就是其结果往往是列表而不是字符串。

    >>> L = [123,'spam',1.23]
    >>> len(L)
    3
    >>> L[0]
    123
    >>> L + [4,5,6]
    [123,'spam',1.23,4,5,6]

**类型特定的操作**

Python列表与其他语言中的数组有些类似，但列表要强大得多。其中一个方面就是，列表没珠类型约束，比如，上面的例子中就有三种不同类型的对象（一个整数、一个字符串、一个浮点数）。此外，列表还能够按照需要增加或减小列表的大小，来响应其特定操作。

    >>> L.append('NI')
    >>> L
    [123,'spam',1.23,'NI']

    >>> L.pop(2)
    1.23
    >>> L
    [123,'spam','NI']

这里，列表的append方法扩充了列表的大小并在列表的尾部插入一项；pop方法（或者等效的del语句）移除给定偏移的一项，从而让列表减小。因为列表是可变的，大多数列表的方法都会改变列表对象，而不是创建一个新的列表。

    >>> M = ['bb','aa','cc']
    >>> M.sort()
    >>> M
    ['aa','bb','cc']
    >>> M.reverse()
    >>> M
    ['cc','bb','aa']

这里排序sort()和反向排序reverse()方法都将直接改变列表。

**边界检查**

尽管列表没有固定的大小，但python不允许引用不存在的元素。

    >>> L
    [123,'spam','NI']
    >>> L[99]
    ...error text omitted...
    >>> L[99] = 1
    ...error text omitted...

给一个列表边界外的元素赋值，会得到一个错误。在python中并不是默默地增大列表作为响应，而会提示错误。为了让一个列表增大，可以调用append这样的列表方法。

**嵌套**

    >>> M = [[1,2,3],[4,5,6],[7,8,9]]
    >>> M[1]
    [4,5,6]
    >>> M[1][2]                         # get row2,then get item3 within the row
    6

这种矩阵结构适用于小规模的任务，但对于更重要的数值运算而言，你可能会想要使用Python数值扩展包中的工具，例如开源NumPy系统。这样的工具能以更高效的方式储存并处理大型矩阵，胜过我们的嵌套列表结构。

**列表解析**

对于列表，python还包括一个更高级的操作。称作列表解析表达式，从而提供了一种处理象矩阵这样结构的强大工具。比如我们要取出矩阵中的第二列。

    >>> col2 = [row[1] for row in M]
    >>> col2
    [2,5,8]

列表解析源自集合的概念。列表解析是编写在方括号中的（提醒你在创建列表这个事实），并且有表达式和循环结构都使用了一个变量名（这里是row）。“把矩阵M中的每个row中的row[1]，放在一个新的列表中”。

    >>> [row[1] + 1 for row in M]
    >>> [3,6,9]
    >>> [row[1] for row in M if row[1] % 2 ==  0]
    [2,8]

    >>> diag = [M[i][i] for i in [0,1,2]]       # collect a diagonal from matrix
    >>> diag
    [1,5,9]

    >>> doubles = [c*2 for c in 'spam']         # repeat characters in a string
    >>> doubles
    ['ss','pp','aa','mm']

列表解析比较复杂，列表解析是一个可选的特性，需要在实际中应用，并常具有速度上的优势。它们也能够在python的任何序列类型中发挥作用，甚至一些不属于序列的类型。

### 字典

Python中的字典是完全不同的东西。它是一种映射。映射是一个其他对象的集合，但是它们是通过键而不是相对位置来存储的，实际上，映射并没有任何可靠的从左至右的顺序，它们简单地将键映射到值。字典是python唯一的映射类型，也具有可变性，可以随需求增大或减小，就象序列那样。

**映射操作**

字典编写在大括号中，并包含了一系列的“键:值”对。

    >>> D = {'food':'spam','quantity':4,'color':'pink'}
    >>> D['food']
    'spam'
    >>> D['quantity'] += 1
    >>> D
    {'food':'spam','color':'pink','quantity':5}

    >>> D = {}                  # create keys by assignment
    >>> D['name'] = 'bob'
    >>> D['job'] = 'dev'
    >>> D['age'] = 40
    >>> D
    {'age':40,'job':'dev','name':'bob'}
    >>> print D['name']
    bob

通过键来索引一个字典往往是python中编写搜索的最快方法。

**重访嵌套**

    >>> rec =   {'name':{'first':'bob','last':'smith'}
                'job':['dev','mgr']
                'age':40.5}
    >>> rec['name']
    {'last':'smith','first':'bob'}
    >>> rec['name']['last']
    'smith'
    >>> rec['job']
    ['dev','mgr']
    >>> rec['job'][-1]
    'mgr'
    >>> rec['job'].append('janitor')
    >>> rec
    {'age':40.5,'name':{'last':'smith','first':'bob'}
    'job':['dev','mgr','janitor']}

从技术来说，python具有一种所谓垃圾收集的特性，在程序运行时可以清理不再使用的内存，并将你从必须管理代码中这样的细节中解放出来。

**键的排序：for循环**

字典不是序列，它不包含任何可靠的从左至右的顺序，那么，如果在一个字典的元素中，我们确实需要强调一个顺序的时候，应该如何做呢？一个简单的解决办法就是通过字典的keys方法收集一个键的列表，并使用列表的sort方法，然后使用python的for循环逐个进行显示结果。

    >>> D = {'a':1,'b':2,'c':3}
    >>> ks = D.keys()
    >>> ks
    ['a','c','b']
    >>> ks.sort()
    >>> ks
    ['a','b','c']
    >>> for key in ks:
        print key, '=>', D[key]
    a => 1
    b => 2
    c => 3

在python最近的版本中，可以使用最新的sorted内置函数（sorted返回结果并对对象类型进行排序）可以一步完成。

    >>> D
    {'a':1,'c':3,'b':2}
    >>> for key in sorted(D):
        print key, '=>', D[key]
    a => 1
    b => 2
    c => 3

for循环就象它的亲戚列表解析一样是一个序列操作。它可以使用在任意一个序列对象，甚至用在一些不是序列的对象中。

    >>> for c in 'spam':
        print c.upper()
    S
    P
    A
    M

**迭代和优化**

for循环就象之前介绍过的列表解析表达式一样，那也没错。它们都是真正的通用迭代工具。事实上，它们都能够工作于遵守迭代协议的任意对象。

    >>> squares = [x ** 2 for x in [1,2,3,4,5]]
    >>> squares
    [1,4,9,16,25]

    >>> squares = []
    >>> for x in [1,2,3,4,5]:
        squares.append(x ** 2)
    >>> squares
    [1,4,9,16,25]

尽管这样，列表解析通常运行地更快（也许快了两倍）。这是大数据集合在程序中重要的原因之一。

python中的一个主要原则就是，首先为了简单和可读性去编写代码，在程序运行后，并证明了确实有必要考虑性能后，再考虑该问题。更多的情况是代码本身已经足够快了。

**不存在的键：if测试**

python中关于字典，当遇到不存在的键值时仍然会返回一个错误。那么，遇到这种情况我们应如何处理并避免错误发生呢？一个技巧就是首先进行测试。字典的has_key方法允许我们查询一个键的存在性。

    >>> D.has_key('f')
    false
    >>> if not D.has_key('f'):
        print 'missing'
    missing

### 元组

元组基本上就象一个不可以改变的列表，元组是序列，但它具有不可变性，和字符串类似。元组的真正的不同之处就在于一旦创建后就不能再改变。也就是说，元组是不可变的序列。

    >>> T = (1,2,3,4)
    >>> len(T)
    4
    >>> T[0]
    1
    >>> T[0] = 2
    ...error text omitted...

### 文件

文件对象是python代码对电脑上外部文件的主要接口。特殊之处：没有特定的常量语法创建文件。可以调用内置的open函数创建一个文件对象。

    >>> f = open('data.txt','w')            # make a new file in output mode
    >>> f.write('hello\n')
    >>> f.write('world\n')
    >>> f.close()

    >>> f = open('data.txt')                # 'r' is the default processing mode
    >>> bytes = f.read()                    # read entire file into a string
    >>> bytes
    'hello\nworld\n'
    >>> print bytes
    hello
    world
    >>> bytes.split()
    ['hello','world']

open函数能够实现在python中编写的绝大多数文件处理。python还有额外的文件类工具：pipes、fifos、sockets、keyed-access files、对象持久、基于描述符的文件、关系数据库和面向对象数据库接口等。

### 其他核心类型

**集合**

集合是最近增加到这门语言中的类型。集合是通过调用内置set函数而创建的对象的容器。

此外，python最近添加的十进制数（固定精度浮点数）和布尔值，以及长期以来一直支持的特殊的点位符对象none

### 如何破坏代码的灵活性

    >>> if type(L) == type([]):
        print 'yes'
    yes
    >>> if type(L) == list:
        print 'yes'
    yes
    >>> if isinstance(L,list):
        print 'yes'
    yes

这是对象检验的所有方法。但在python程序中这样做是错误的。在代码中检验了特定的类型，实际上破坏了它的灵活性，即限制它只能使用一种类型工作。如果没有这样的检测，代码也许能够使用整个范围的类型工作。

### 用户定义的类

我们将深入学习python中的面向对象编程。类定义了新的对象类型，扩展了核心类型。

    >>> class worker:
            def __init__(self,name,pay):        # initialize when created
                self.name = name
                self.pay = pay
            def lastname(self):
                return self.name.split()[-1]    # split string on blanks
            def GiveRaise(self,percent):
                self.pay *= (1.0+percent)       # update pay in-place
                
    >>> bob = worker('bob smith',50000)
    >>> sue = worker('sue jones',60000)
    >>> bob.lastname()
    'smith'
    >>> sue.lastname()
    'jones'
    >>> sue.GiveRaise(.10)
    >>> sue.pay
    66000.0
    
采用的'self'对象是我们把这叫做面向对象模型的原因。关于类更多的知识及其继承机制使python支持了软件层次，使其可以通过扩展进行定制。但你应该知道，类是python可选的一个特性，并且与用户编写的类相比，像列表和字典这样的更简单的内置类型往往是更好的工具。

## 第5章 数字

内置数学工具和扩展

表达式操作符：+、*、>>、**等。

内置数学函数：pow、abs等

公用模块：random、math等。

可以通过手动调用内置函数来强制转换类型，然而通常是没有必要这样做的，因为python在表达式中自动升级为更复杂的类型，其结果往往就是你所想要的。

整数除法，如果结果是一个小数，但因为python默认为整数结果，所以结果会得到一个整数。

由于浮点数的硬件限制，交互提示模式下结果的自动回显会比打印语句显示更多的数字位数。如果你不想看到所有的位数，考虑使用print。

    >>> num = 1/3.0
    >>> num
    0.33333333333331
    >>> print num
    0.3333333333333
    >>> "%e" % num
    '3.333333e-001'
    >>> "%2.2f" % num
    0.33

    >>> repr(num)                   # used by echoes: as-code form
    '0.33333333333331'
    >>> str(num)                    # used by print: user-friendly form
    '0.333333333333'

除法：传统除法、Floor除法和真除法。在版本2.x以前，采用传统除法，这个操作会省去小数部分，对于浮点数会保持小数部分；而在版本3.0中将变为真除法（无论任何类型都会保持小数部分），可以通过特定的导入形式来使用这种未来将会采用的真除操作。

    >>> from __future__ import division

Floor除法是在python2.2中新增的操作，这个操作不考虑操作对象的类型，总会省略掉结果的小数部分，剩下最小的能整除的整数部分。

十六进制和八进制记数

    >>> oct(64), hex(64), hex(255)
    ('0100','0x40','0xff')

oct函数会将十进制数转换为八进制数，hex函数会将十进制数转换为十六进制数。另一种方式，内置的int函数会将一个数字的字符串变换为一个整数，并可以通过定义的第二个参数来确定变换后的数字的进制。

    >>> int('0100'), int('0100',8), int('0x40',16)
    (100,64,64)

eval函数，将会把字符串作为python代码。因此，它也具有类似的效果，但往往运行得更慢。

    >>> eval('100'), eval('0100'), eval('0x40')
    (100,64,64)

你也可以将一个整数通过字符串格式表达式转换成八进制数和十六进制数的字符串。

    >>> "%0 %x %X % (64,64,255)
    '100 40 FF'

注意在python中不要以使用0开头的数字字符串，除非你真正想要编写的是一个八进制数。python将会把它当作八进制数。

其他的内置数学工具

    >>> import math
    >>> math.pi, math.e                 # common constants
    (3.1415926535897931, 2.7182818284590451)
    >>> math.sin(2 * math.pi / 180)
    0.03489...
    >>> math.sqrt(144), math.sqrt(2)    # square root
    (12.0, 1.414213562...)
    >>> abs(-42), 2**4, pow(2,4)        # abs返回绝对值,pow指2为底，4是指数
    (42,16,16)
    >>> int(2.567), round(2.567), round(2.567,2)    # 取整，四舍五入
    (2,3.0,2.57)

注意内置math模块必须先导入，而abs这样的内置函数不需要。

random模块也要导入，这个模块提供了一个在0和1之间的任意浮点数、选择在两个数字之间的任意整数、在一个序列中任意挑选一项等功能。

    >>> import random
    >>> random.random()
    0.49741978....
    >>> random.random()
    0.4935486643.....

    >>> random.randint(1,10)
    5
    >>> radom.randint(1,10)
    4

    >>> random.choice(['life of brian', 'holy grail', 'meaning of life'])
    'life of brian'
    >>> random.choice(['life of brian', 'holy grail', 'meaning of life'])
    'holy grail'

其他数字类型。python还自带了一些更少见的数字类型。

+   小数数字
        
        >>> print 0.1+0.1+0.1-0.3
        5.55111512313e-017
        >>> from decimal import decimal
        >>> decimal('0.1')+decimal('0.1')+decimal('0.1')-decimal('0.3')
        decimal("0.0")

+   集合

